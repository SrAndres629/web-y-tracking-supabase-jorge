import os
import time
import subprocess
import shutil
import sys
import datetime

# Configuration
AI_DIR = os.path.dirname(os.path.abspath(__file__))
MOTOR_DIR = os.path.join(AI_DIR, "motor")
SENSORY_DIR = os.path.join(AI_DIR, "sensory")
SIGNALS_DIR = os.path.join(AI_DIR, "signals")
MEMORY_DIR = os.path.join(AI_DIR, "memory")

# ‚ö° AGENT BRAIN PARAMETERS
AGENT_TIMEOUT = 1800
MAX_RETRIES = 3

# Retry Tracking
task_retries = {}

# üß† AGENT PROTOCOLS (Using venv-aware relative commands)
AGENTS = {
    "codex":  {"cmd": "codex",  "prefix_args": ["exec"]}, 
    "kimi":   {"cmd": "kimi",   "prefix_args": []},   
    "gemini": {"cmd": "gemini", "prefix_args": ["-p"]}
}

# üìú HIVE MIND PROTOCOL (The "System Prompt")
HIVE_MIND_PROTOCOL = """
!!! SYSTEM INSTRUCTION: HIVE MIND PROTOCOL V1.0 !!!
You are an autonomous agent operating within the "Hive Mind" architecture. 
Your goal is to complete the assigned task with MAXIMUM PRECISION and ZERO HALLUCINATIONS.

Team Roster:
- GEMINI: Data Flow & Logic Specialist
- KIMI: Architecture & Integrity Specialist
- CODEX: Implementation & Fix Specialist
- SUPERVISOR: Audit & Orchestration

PRIME DIRECTIVES:
1. CHAIN OF THOUGHT: You MUST plan your actions step-by-step before executing.
   - Example: "Plan: 1. Analyze file. 2. check permissions. 3. write report."
2. PERMISSIONS:
   - READ: Entire Codebase.
   - WRITE: ONLY files explicitly listed in the "Scoped Permissions" or "Objectives".
   - DO NOT edit files outside your scope to avoid conflicts.
3. CRITICAL THINKING:
   - Challenge assumptions. If the task code looks buggy, fix it or report it.
   - Do not Assume: VERIFY.
4. HARMONIC COLLABORATION:
   - Assume other agents are working.
   - If you see a file generated by another agent in `.ai/sensory/`, READ IT to align your context.

[END SYSTEM INSTRUCTION]
"""

def log(msg, symbol="üß†"):
    timestamp = datetime.datetime.now().strftime("%H:%M:%S")
    print(f"[{timestamp}] {symbol} [SYNAPSE] {msg}")

def signal_antigravity(agent_name):
    try:
        if not os.path.exists(SIGNALS_DIR): os.makedirs(SIGNALS_DIR)
        signal_file = os.path.join(SIGNALS_DIR, "WAKE_UP_ANTIGRAVITY")
        with open(signal_file, "w") as f:
            f.write(f"Agent {agent_name} completed task at {time.time()}")
    except Exception as e:
        log(f"Signal failure: {e}", "‚ö†Ô∏è")

def update_visual_cortex():
    """Triggers an incremental scan of the Visual Cortex."""
    try:
        # We assume the cortex module is available if synapse is running
        # Add .ai directory to path
        if AI_DIR not in sys.path:
            sys.path.insert(0, AI_DIR)

        from core.vision.cortex import VisualCortex
        cortex = VisualCortex()
        # Full scan for now to be safe, or we could parse the diffs from logs later
        # Optimization: We should ideally only scan changed files.
        # identifying changed files requires parsing git status or the task output.
        # For V1 MVP, we trigger a full scan (it's fast for <500 files).
        root = os.path.dirname(AI_DIR) # Project root
        cortex.scan_project(root)
        log("Visual Cortex updated.", "üëÅÔ∏è")
    except Exception as e:
        log(f"Visual Cortex update failed: {e}", "‚ö†Ô∏è")

def save_sensory_trace(agent_name, cmd, exit_code, stdout, stderr):
    try:
        report_content = f"# EXECUTION REPORT: {agent_name.upper()}\n"
        report_content += f"## Command: {cmd}\n"
        report_content += f"## Status: {exit_code}\n\n"
        report_content += f"### STDOUT\n```\n{stdout}\n```\n\n"
        report_content += f"### STDERR\n```\n{stderr}\n```\n"
        
        timestamp = int(time.time())
        sensory_file = os.path.join(SENSORY_DIR, f"trace_{timestamp}_{agent_name}.md")
        with open(sensory_file, "w", encoding="utf-8") as f:
            f.write(report_content)
        log(f"Sensory Trace captured: {sensory_file}", "üì•")
        
        if exit_code != 0:
             print(f"   >> STDERR: {stderr[:200]}...")

    except Exception as e:
        log(f"Sensory Save Failed: {e}", "üî•")

def stream_command(command, cwd, env):
    """Streams command output in real-time while capturing it."""
    process = subprocess.Popen(
        command,
        cwd=cwd,
        env=env,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        encoding="utf-8",
        errors="replace",
        bufsize=1  # Line buffered
    )

    captured_stdout = []
    captured_stderr = []

    # Stream stdout in real-time
    while True:
        output = process.stdout.readline()
        if output == "" and process.poll() is not None:
            break
        if output:
            print(output.strip()) # Real-time visual feedback
            captured_stdout.append(output)

    # Capture any remaining stderr
    stderr_output = process.stderr.read()
    if stderr_output:
        print(f"   >> STDERR: {stderr_output.strip()}")
        captured_stderr.append(stderr_output)

    return_code = process.poll()
    return return_code, "".join(captured_stdout), "".join(captured_stderr)


def execute_agent(agent_name, task_file):
    log(f"Triggering Agent: {agent_name.upper()}", "‚ö°")
    
    agent_config = AGENTS.get(agent_name)
    if not agent_config:
        log(f"Unknown agent: {agent_name}", "‚ùå")
        return False

    cmd_path = agent_config["cmd"]
    prefix_args = agent_config["prefix_args"]
    
    try:
        task_filename = os.path.basename(task_file)
        
        # Read Task Content
        try:
            with open(task_file, "r", encoding="utf-8") as f:
                raw_content = f.read()
        except:
            raw_content = "Task file read error"

        # üß† INJECT PROTOCOL
        final_task_content = f"{HIVE_MIND_PROTOCOL}\n\n[TASK START]\n{raw_content}\n[TASK END]"

        # Construct Command: [CMD, ARGS..., CONTENT]
        if len(final_task_content) > 30000:
            log(f"‚ö†Ô∏è Task content too large ({len(final_task_content)} chars). Truncating...", "‚úÇÔ∏è")
            final_task_content = final_task_content[:30000]

        full_command = [cmd_path] + prefix_args + [final_task_content]
        
        log(f"   >> Executing: {os.path.basename(cmd_path)} (Args: {prefix_args})", "‚öôÔ∏è")
        print(f"   >> LIVE FEED INITIATED [STREAMING]...\n")

        # üîß ENVIRONMENT FIX (Enforce venv priority)
        env = os.environ.copy()
        venv_scripts = os.path.join(os.path.dirname(AI_DIR), "venv", "Scripts")
        if os.path.exists(venv_scripts):
            env["PATH"] = venv_scripts + os.pathsep + env.get("PATH", "")
        
        env["PYTHONIOENCODING"] = "utf-8"
        env["LANG"] = "en_US.UTF-8"
        env["PYTHONLEGACYWINDOWSSTDIO"] = "utf-8" 

        use_shell = False
        if cmd_path.endswith(".cmd"):
            use_shell = True 
            
        # üöÄ REAL-TIME STREAMING EXECUTION
        return_code, stdout, stderr = stream_command(
            full_command, 
            cwd=AI_DIR,
            env=env
        )
        
        save_sensory_trace(agent_name, str(full_command[:2]), return_code, stdout, stderr)
        
        if return_code != 0:
            log(f"Agent process exited with code {return_code}", "‚ö†Ô∏è")
            return False
            
        log(f"Agent process completed successfully.", "‚úÖ")
        
        # üëÅÔ∏è VISUAL CORTEX UPDATE (Post-Task Hook)
        update_visual_cortex()
        
        return True

    except Exception as e:
        log(f"Execution failed: {e}", "üî•")
        save_sensory_trace(agent_name, "EXCEPTION", "EXCEPTION", "", str(e))
        return False

def check_motor_cortex():
    if not os.path.exists(MOTOR_DIR): return

    files = [f for f in os.listdir(MOTOR_DIR) if f.startswith("task_") and f.endswith(".md")]
    
    if "task_halt.md" in files:
        log("üõë HALT SIGNAL RECEIVED.", "üîå")
        try: os.remove(os.path.join(MOTOR_DIR, "task_halt.md")) 
        except: pass
        sys.exit(0)

    for filename in files:
        if filename == "task_halt.md": continue

        task_path = os.path.join(MOTOR_DIR, filename)
        
        # Handle user-generated tasks by assigning them to Kimi for planning
        if filename.startswith("task_user_"):
            log(f"New user directive received: {filename}. Assigning to Kimi for planning.", "üßë‚Äçüíª")
            new_filename = filename.replace("user_", "kimi_plan_")
            new_task_path = os.path.join(MOTOR_DIR, new_filename)

            try:
                with open(task_path, "r", encoding="utf-8") as f:
                    content = f.read()
                
                prepended_content = f"# PARENT-TASK: {filename}\n\n{content}"

                with open(task_path, "w", encoding="utf-8") as f:
                    f.write(prepended_content)
                
                shutil.move(task_path, new_task_path)
                log(f"Task reassigned to Kimi: {new_filename}", "ü§ñ")
                continue # Continue to the next loop iteration to process the newly named file
            except Exception as e:
                log(f"Error reassigning user task: {e}", "‚ùå")
                continue

        parts = filename.replace("task_", "").replace(".md", "").split("_")
        agent_name = parts[0] 
        
        if agent_name in AGENTS:
            success = execute_agent(agent_name, task_path)
            
            if success:
                target_dir = MEMORY_DIR
            else:
                retries = task_retries.get(filename, 0)
                if retries < MAX_RETRIES:
                    task_retries[filename] = retries + 1
                    log(f"üîÑ RETRY {task_retries[filename]}/{MAX_RETRIES}...", "ü©π")
                    continue
                target_dir = os.path.join(MEMORY_DIR, "failed")

            if not os.path.exists(target_dir): os.makedirs(target_dir)
            try:
                shutil.move(task_path, os.path.join(target_dir, f"done_{int(time.time())}_{filename}"))
            except: pass
            
            if filename in task_retries: del task_retries[filename]
            signal_antigravity(agent_name)

def main():
    log("Neural Network Online. Monitoring Motor Cortex...", "üåê")
    for d in [MOTOR_DIR, SENSORY_DIR, SIGNALS_DIR, MEMORY_DIR]:
        if not os.path.exists(d): os.makedirs(d)
    print(f"[{datetime.datetime.now().strftime('%H:%M:%S')}] üåê [SYNAPSE] Neural Network Online. Waiting for tasks in .ai/motor/...", end="", flush=True)
    
    last_check = 0
    while True:
        try:
            # Active Mode Check
            has_tasks = len([f for f in os.listdir(MOTOR_DIR) if f.startswith("task_") and f.endswith(".md")]) > 0
            
            if has_tasks:
                if last_check == 0: print("\n") # New line for active mode
                check_motor_cortex()
                last_check = 0 # Reset wait counter
            else:
                # Wait Mode Visualization (Pulse)
                if time.time() - last_check > 5:
                    print(".", end="", flush=True)
                    last_check = time.time()
                time.sleep(1)
                
        except SystemExit:
            log("Shutting down...", "üîå")
            raise
        except KeyboardInterrupt:
            log("Manual Interruption.", "üõë")
            sys.exit(0)
        except Exception as e:
            log(f"CRITICAL SYNAPSE ERROR: {e}", "üî•")
            time.sleep(5)

if __name__ == "__main__":
    main()

"""
PAGES.PY - Rutas de p√°ginas HTML (FastAPI Background Tasks)
Jorge Aguirre Flores Web
"""

import logging
import os
import random
import time
from typing import Any, Dict, List, Optional, cast

from fastapi import APIRouter, BackgroundTasks, Cookie, Request, Response
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

from app.config import settings
from app.interfaces.api.dependencies import get_legacy_facade
from app.services import get_contact_config, get_services_config
from app.services.seo_engine import SEOEngine

logger = logging.getLogger("BackgroundWorker")

router = APIRouter()
legacy = get_legacy_facade()

# üóÑÔ∏è TEMPLATE CONFIG (Using Centralized Settings)
templates = Jinja2Templates(directory=settings.TEMPLATES_DIRS)

# üïí SILICON VALLEY VERSIONING: Unique ID per-process start
# This forces global cache bust when the app restarts (deploy)
SYSTEM_VERSION: str = str(int(time.time()))
# Cast to Any to satisfy static analysis for dynamic Jinja2 attributes
templates_obj = cast(Any, templates)
templates_env = templates_obj.env
templates_env.globals["system_version"] = SYSTEM_VERSION
logger.info("üíé SYSTEM CORE: Version %s initialized.", SYSTEM_VERSION)


# =================================================================
# MINI-WORKERS (Execute after HTTP response)
# =================================================================


def bg_save_visitor(
    external_id: str,
    fbclid: str,
    client_ip: str,
    user_agent: str,
    source: str,
    utm_data: Dict[str, Any],
    email: Optional[str] = None,
    phone: Optional[str] = None,
) -> None:
    """Saves visitor without blocking page render"""
    try:
        legacy.save_visitor(
            external_id,
            fbclid,
            client_ip,
            user_agent,
            source,
            utm_data,
            email=email,
            phone=phone,
        )
        preview: str = external_id[slice(0, 16)]
        logger.info("‚úÖ [BG] Visitor saved: %s...", preview)
    except (AttributeError, KeyError, ValueError, RuntimeError):
        logger.exception("‚ùå [BG] Error saving visitor")


async def bg_send_pageview(
    event_source_url: str,
    client_ip: str,
    user_agent: str,
    event_id: str,
    fbclid: str,
    fbp: Optional[str],
    external_id: str,
    city: Optional[str] = None,
    state: Optional[str] = None,
    country: Optional[str] = None,
) -> None:
    """Sends PageView to Meta CAPI via Official SDK (Elite Service)"""
    try:
        # Construct fbc cookie if fbclid is present
        fbc_cookie: Optional[str] = None
        if fbclid:
            timestamp: int = int(time.time())
            fbc_cookie = f"fb.1.{timestamp}.{fbclid}"

        result: Dict[str, Any] = await legacy.send_elite_event(
            event_name="PageView",
            event_id=event_id,
            url=event_source_url,
            client_ip=client_ip,
            user_agent=user_agent,
            external_id=external_id,
            fbc=fbc_cookie,
            fbp=fbp,
            city=city,
            state=state,
            country=country,
            custom_data={},
        )

        status: Optional[str] = result.get("status")
        if status == "success":
            logger.info("‚úÖ [BG] PageView sent to Meta CAPI")
        else:
            logger.warning("‚ö†Ô∏è [BG] PageView issue: %s", result)
    except (AttributeError, KeyError, ValueError, RuntimeError):
        logger.exception("‚ùå [BG] PageView error")


# =================================================================
# PAGE ROUTES
# =================================================================


@router.head("/", response_class=HTMLResponse)
async def head_root() -> Response:
    """HEAD response for UptimeRobot (no tracking)"""
    return Response(status_code=200)


@router.get("/", response_class=HTMLResponse)
async def read_root(
    request: Request,
    background_tasks: BackgroundTasks,
    fbp_cookie: Optional[str] = Cookie(default=None, alias="_fbp"),
    fbc_cookie: Optional[str] = Cookie(default=None, alias="_fbc"),
) -> Response:
    """P√ÅGINA DE INICIO - Optimized for Speed & Tracking."""
    # 1. Identity & Config
    ident: Dict[str, Any] = _extract_identity_info(request)
    ab_variant: str = _handle_ab_test(request)
    services_config: List[Dict[str, Any]] = await get_services_config()
    contact_config: Dict[str, Any] = await get_contact_config()
    hero_content: Dict[str, Any] = _get_hero_content(request.query_params)

    # 2. Tracking Identity
    event_id = str(int(time.time() * 1000))
    # external_id is generated by legacy facade
    external_id: str = legacy.generate_external_id(ident["ip"], ident["ua"])
    fbclid = await _resolve_fbclid_full(request, fbc_cookie, external_id)

    # 4. SEO Engine (Silicon Valley Research Standard)
    # Page metadata
    seo_meta: Dict[str, Any] = SEOEngine.get_page_metadata(
        "/",
        {
            "title": ("Jorge Aguirre Flores | Experto en Microblading y Est√©tica Avanzada"),
            "description": (
                "Transforma tu mirada con el mejor especialista en "
                "Microblading de Santa Cruz. 30 a√±os de trayectoria "
                "garantizan resultados naturales y art√≠sticos."
            ),
        },
    )
    # Schemas
    schemas = [
        SEOEngine.get_global_schema(),
        SEOEngine.get_breadcrumb_schema([{"name": "Inicio", "path": "/"}]),
    ]

    # 5. Background Tasks & Cookies
    _schedule_tracking(background_tasks, request, ident, external_id, fbclid, fbp_cookie, event_id)

    # 6. Build Response with optimized caching headers
    response: Response = templates.TemplateResponse(
        request=request,
        name="pages/site/home.html",
        context={
            "pixel_id": settings.META_PIXEL_ID,
            "pageview_event_id": event_id,
            "external_id": external_id,
            "fbclid": fbclid or "",
            "zaraz_debug_key": os.getenv("ZARAZ_DEBUG_KEY"),
            "services": services_config,
            "contact": contact_config,
            "google_client_id": settings.GOOGLE_CLIENT_ID,
            "clarity_id": settings.CLARITY_PROJECT_ID,
            "turnstile_site_key": settings.TURNSTILE_SITE_KEY,
            "flags": _get_feature_flags(),
            "hero_content": hero_content,
            "ab_variant": ab_variant,
            "seo": {**seo_meta, "json_ld": SEOEngine.generate_all_json_ld(schemas)},
        },
        headers={
            "Cache-Control": ("public, max-age=3600, stale-while-revalidate=86400"),
            "CDN-Cache-Control": "public, max-age=3600",
            "Vercel-CDN-Cache-Control": "public, max-age=3600",
        },
    )
    _set_identity_cookies(response, ab_variant, ident, fbclid, fbp_cookie)
    return response


@router.get("/tracking-motor", response_class=HTMLResponse)
async def read_tracking_motor(
    request: Request,
    background_tasks: BackgroundTasks,
    fbp_cookie: Optional[str] = Cookie(default=None, alias="_fbp"),
    fbc_cookie: Optional[str] = Cookie(default=None, alias="_fbc"),
) -> Response:
    """LANDING PAGE VENTA TRACKING ENGINE - Optimized for B2B Conversion."""
    # 1. Identity & Config
    ident: Dict[str, Any] = _extract_identity_info(request)
    services_config: List[Dict[str, Any]] = await get_services_config()
    contact_config: Dict[str, Any] = await get_contact_config()

    # 2. Tracking Identity
    event_id = str(int(time.time() * 1000))
    external_id: str = legacy.generate_external_id(ident["ip"], ident["ua"])
    fbclid = await _resolve_fbclid_full(request, fbc_cookie, external_id)

    # 4. SEO Engine
    seo_meta: Dict[str, Any] = SEOEngine.get_page_metadata(
        "/tracking-motor",
        {
            "title": "Anti-Gravity Tracking Core | Meta CAPI Atomic Motor",
            "description": (
                "Recupera el 40% de tu data perdida. El motor de tracking m√°s "
                "avanzado con deduplicaci√≥n at√≥mica y EMQ Optimization."
            ),
        },
    )

    schemas = [
        SEOEngine.get_global_schema(),
        SEOEngine.get_breadcrumb_schema(
            [
                {"name": "Inicio", "path": "/"},
                {"name": "Tracking Motor", "path": "/tracking-motor"},
            ]
        ),
    ]

    # 5. Background Tasks
    _schedule_tracking(background_tasks, request, ident, external_id, fbclid, fbp_cookie, event_id)

    # 6. Build Response with optimized caching
    response: Response = templates.TemplateResponse(
        request=request,
        name="pages/site/tracking_motor.html",
        context={
            "pixel_id": settings.META_PIXEL_ID,
            "pageview_event_id": event_id,
            "external_id": external_id,
            "fbclid": fbclid or "",
            "services": services_config,
            "contact": contact_config,
            "seo": {**seo_meta, "json_ld": SEOEngine.generate_all_json_ld(schemas)},
        },
        headers={
            "Cache-Control": ("public, max-age=3600, stale-while-revalidate=86400"),
            "CDN-Cache-Control": "public, max-age=3600",
            "Vercel-CDN-Cache-Control": "public, max-age=3600",
        },
    )
    _set_identity_cookies(response, "variant_a", ident, fbclid, fbp_cookie)
    return response


@router.get("/microblading", response_class=HTMLResponse)
async def read_microblading(
    request: Request,
    background_tasks: BackgroundTasks,
    fbp_cookie: Optional[str] = Cookie(default=None, alias="_fbp"),
    fbc_cookie: Optional[str] = Cookie(default=None, alias="_fbc"),
) -> Response:
    """P√ÅGINA: Microblading HD - Ingenier√≠a de la Mirada."""
    return await _render_service_page(
        request, background_tasks, "microblading", fbp_cookie, fbc_cookie
    )


@router.get("/cejas", response_class=HTMLResponse)
async def read_brows(
    request: Request,
    background_tasks: BackgroundTasks,
    fbp_cookie: Optional[str] = Cookie(default=None, alias="_fbp"),
    fbc_cookie: Optional[str] = Cookie(default=None, alias="_fbc"),
) -> Response:
    """P√ÅGINA: Sombreado Dual (Powder Brows)."""
    return await _render_service_page(request, background_tasks, "brows", fbp_cookie, fbc_cookie)


@router.get("/ojos", response_class=HTMLResponse)
async def read_eyes(
    request: Request,
    background_tasks: BackgroundTasks,
    fbp_cookie: Optional[str] = Cookie(default=None, alias="_fbp"),
    fbc_cookie: Optional[str] = Cookie(default=None, alias="_fbc"),
) -> Response:
    """P√ÅGINA: Ocular Precision (Eyeliner)."""
    return await _render_service_page(request, background_tasks, "eyeliner", fbp_cookie, fbc_cookie)


@router.get("/labios", response_class=HTMLResponse)
async def read_lips(
    request: Request,
    background_tasks: BackgroundTasks,
    fbp_cookie: Optional[str] = Cookie(default=None, alias="_fbp"),
    fbc_cookie: Optional[str] = Cookie(default=None, alias="_fbc"),
) -> Response:
    """P√ÅGINA: Full Lip Velvet (Acuarela de Labios)."""
    return await _render_service_page(request, background_tasks, "lips", fbp_cookie, fbc_cookie)


async def _render_service_page(
    request: Request,
    background_tasks: BackgroundTasks,
    service_id: str,
    fbp_cookie: Optional[str],
    fbc_cookie: Optional[str],
) -> Response:
    """Helper to render service pages with specialized elite logic."""
    ident = _extract_identity_info(request)
    services_config = await get_services_config()
    contact_config = await get_contact_config()

    # Find specific service
    service = next((s for s in services_config if s["id"] == service_id), None)
    if not service:
        # Fallback to first if not found (defensive)
        service = services_config[0]

    event_id = str(int(time.time() * 1000))
    external_id = legacy.generate_external_id(ident["ip"], ident["ua"])
    fbclid = await _resolve_fbclid_full(request, fbc_cookie, external_id)

    # SEO Specialized for the service
    seo_meta = SEOEngine.get_page_metadata(
        f"/{service_id}",
        {
            "title": f"{service['title']} | Jorge Aguirre Flores Elite",
            "description": service["description"],
        },
    )

    schemas = [
        SEOEngine.get_global_schema(),
        SEOEngine.get_service_schema(service),
        SEOEngine.get_breadcrumb_schema(
            [
                {"name": "Inicio", "path": "/"},
                {"name": service["title"], "path": f"/{service_id}"},
            ]
        ),
    ]

    _schedule_tracking(background_tasks, request, ident, external_id, fbclid, fbp_cookie, event_id)

    response = templates.TemplateResponse(
        request=request,
        name=f"pages/site/{service_id}.html",
        context={
            "pixel_id": settings.META_PIXEL_ID,
            "pageview_event_id": event_id,
            "external_id": external_id,
            "fbclid": fbclid or "",
            "service": service,
            "all_services": services_config,
            "contact": contact_config,
            "seo": {**seo_meta, "json_ld": SEOEngine.generate_all_json_ld(schemas)},
        },
    )
    _set_identity_cookies(response, "variant_a", ident, fbclid, fbp_cookie)
    return response


@router.get("/onboarding", response_class=HTMLResponse)
async def read_onboarding(request: Request) -> Response:
    """CLIENT ONBOARDING PAGE - Self-service credential generation."""
    seo_meta: Dict[str, Any] = SEOEngine.get_page_metadata(
        "/onboarding",
        {
            "title": "Onboarding | Atomic Tracking Motor",
            "description": ("Configura tu motor de tracking y genera tu API Key en 5 minutos."),
        },
    )

    services_config: List[Dict[str, Any]] = await get_services_config()
    contact_config: Dict[str, Any] = await get_contact_config()

    return templates.TemplateResponse(
        request=request,
        name="pages/site/onboarding.html",
        context={
            "seo": seo_meta,
            "services": services_config,
            "contact": contact_config,
        },
    )


@router.get("/privacidad", response_class=HTMLResponse)
async def read_privacy(request: Request) -> Response:
    """Privacy Policy Page."""
    return templates.TemplateResponse(
        request=request,
        name="pages/site/legal.html",
        context={
            "title": "Pol√≠tica de Privacidad",
            "page_type": "privacy",
            "updated_date": "Febrero 2026",
            "contact": await get_contact_config(),
        },
    )


@router.get("/privacy", response_class=HTMLResponse)
async def read_privacy_en(request: Request) -> Response:
    """Privacy Policy Page (English Alias)."""
    return await read_privacy(request)


@router.get("/terminos", response_class=HTMLResponse)
async def read_terms(request: Request) -> Response:
    """Terms & Conditions Page."""
    return templates.TemplateResponse(
        request=request,
        name="pages/site/legal.html",
        context={
            "title": "T√©rminos y Condiciones",
            "page_type": "terms",
            "updated_date": "Febrero 2026",
            "contact": await get_contact_config(),
        },
    )


@router.get("/terms", response_class=HTMLResponse)
async def read_terms_en(request: Request) -> Response:
    """Terms & Conditions Page (English Alias)."""
    return await read_terms(request)


@router.get("/cookies", response_class=HTMLResponse)
async def read_cookies(request: Request) -> Response:
    """Cookies Policy Page."""
    return templates.TemplateResponse(
        request=request,
        name="pages/site/legal.html",
        context={
            "title": "Pol√≠tica de Cookies",
            "page_type": "cookies",
            "updated_date": "Febrero 2026",
            "contact": await get_contact_config(),
        },
    )


def _extract_identity_info(request: Request) -> Dict[str, Any]:
    forwarded = request.headers.get("x-forwarded-for")
    cf_ip = request.headers.get("cf-connecting-ip")
    host: str = "unknown"
    if request.client:
        host = request.client.host
    return {
        "ip": (cf_ip or (forwarded.split(",")[0].strip() if forwarded else host)),
        "ua": request.headers.get("user-agent", ""),
        "country": request.headers.get("cf-ipcountry"),
        "city": request.headers.get("cf-ipcity"),
        "region": (request.headers.get("cf-region") or request.headers.get("cf-region-code")),
    }


def _handle_ab_test(request: Request) -> str:
    variant: Optional[str] = request.cookies.get("ab_test_group")
    if not variant:
        variant = "variant_b" if random.random() > 0.5 else "variant_a"
    return str(variant)


def _get_hero_content(params: Any) -> Dict[str, Any]:
    utm: str = params.get("utm_campaign", "").lower()
    content: Dict[str, Any] = {
        "title": (
            'Ingenier√≠a de la <span class="italic font-light text-gradient-gold">Mirada</span>'
        ),
        "subtitle": "Especialista en Microblading",
        "bg_class": "bg-luxury-black",
        "is_dynamic": False,
    }
    if "labios" in utm or "lips" in utm:
        content.update(
            {
                "title": (
                    'Arte y Volumen en tus <span class="italic font-light '
                    'text-gradient-gold">Labios</span>'
                ),
                "subtitle": "Micropigmentaci√≥n Full Color",
                "is_dynamic": True,
            }
        )
    elif "ojos" in utm or "delineado" in utm or "eyes" in utm:
        content.update(
            {
                "title": (
                    'Tu Mirada, Perfectamente <span class="italic font-light '
                    'text-gradient-gold">Delineada</span>'
                ),
                "subtitle": "Delineado Permanente de Ojos",
                "is_dynamic": True,
            }
        )
    elif "cejas" in utm or "brows" in utm:
        content.update(
            {
                "title": (
                    'Cejas Perfectas, <span class="italic font-light '
                    'text-gradient-gold">Pelo a Pelo</span>'
                ),
                "subtitle": "Microblading 3D Hiper-Realista",
                "is_dynamic": True,
            }
        )
    return content


async def _resolve_fbclid_full(
    request: Request, fbc_cookie: Optional[str], external_id: str
) -> Optional[str]:
    """
    Resolves FBCLID with zero-latency priority.
    1. URL (Immediate)
    2. Cookie (Immediate)
    3. Redis Cache (Fast - <15ms)
    4. (SKIP) DB lookup is too slow for initial render (approx 1-2s delay)
    """
    # 1. URL Parameter (highest priority)
    fbclid: Optional[str] = request.query_params.get("fbclid")
    if fbclid:
        return fbclid

    # 2. Cookie (_fbc)
    if fbc_cookie and fbc_cookie.startswith("fb.1."):
        parts: List[str] = fbc_cookie.split(".")
        if len(parts) >= 4:
            return parts[3]

    # 3. Redis Cache (L2 Identity)
    try:
        cached: Optional[Dict[str, Any]] = legacy.get_cached_visitor(external_id)
        if cached and cached.get("fbclid"):
            return str(cached.get("fbclid"))
    except (AttributeError, KeyError, ValueError, RuntimeError) as e:
        logger.debug("Identity cache miss: %s", e)

    # 4. üî• SKIP DB: For new visitors, we don't block 5 seconds.
    # The background task 'bg_save_visitor' will eventually link it.
    return None


def _schedule_tracking(
    bt: BackgroundTasks,
    request: Request,
    ident: Dict[str, Any],
    ext_id: str,
    fbclid: Optional[str],
    fbp: Optional[str],
    event_id: str,
) -> None:
    if not getattr(request.state, "is_human", True):
        return

    bt.add_task(
        bg_save_visitor,
        ext_id,
        fbclid or "",
        ident["ip"],
        ident["ua"],
        "pageview",
        {
            "utm_source": request.query_params.get("utm_source"),
            "utm_medium": request.query_params.get("utm_medium"),
            "utm_campaign": request.query_params.get("utm_campaign"),
        },
        email=None,
        phone=None,
    )
    if fbclid:
        bt.add_task(legacy.cache_visitor_data, ext_id, {"fbclid": fbclid})

    bt.add_task(
        bg_send_pageview,
        str(request.url),
        ident["ip"],
        ident["ua"],
        event_id,
        fbclid or "",
        fbp,
        ext_id,
        ident["city"],
        ident["region"],
        ident["country"],
    )


def _set_identity_cookies(
    response: Response,
    variant: str,
    ident: Dict[str, Any],
    fbclid: Optional[str],
    fbp: Optional[str],
) -> None:
    response.set_cookie(key="ab_test_group", value=variant, max_age=2592000)
    if not ident.get("is_human", True):
        return

    if not fbp:
        val: str = f"fb.1.{int(time.time() * 1000)}.{random.randint(100000000, 999999999)}"
        response.set_cookie(
            key="_fbp",
            value=val,
            max_age=31536000,
            httponly=False,
            secure=True,
            samesite="lax",
        )

    if fbclid:
        val = f"fb.1.{int(time.time())}.{fbclid}"
        response.set_cookie(
            key="_fbc",
            value=val,
            max_age=31536000,
            httponly=False,
            secure=True,
            samesite="lax",
        )


def _get_feature_flags() -> Dict[str, Any]:
    return {
        "show_testimonials": settings.FLAG_SHOW_TESTIMONIALS,
        "show_gallery": settings.FLAG_SHOW_GALLERY,
        "enable_chat_widget": settings.FLAG_ENABLE_CHAT_WIDGET,
        "cta_variant": settings.FLAG_CTA_VARIANT,
        "hero_style": settings.FLAG_HERO_STYLE,
        "meta_tracking": settings.FLAG_META_TRACKING,
        "maintenance_mode": settings.FLAG_MAINTENANCE_MODE,
        "booking_enabled": settings.FLAG_BOOKING_ENABLED,
    }
